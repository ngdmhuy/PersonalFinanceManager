\section{System Implementation Details}

\subsection{Data Modeling \& Class Design}
The application utilizes a strict Object-Oriented design to represent financial entities. The data model is divided into three distinct categories: Core Transactions, Automation Templates, and Master Data.

\subsubsection{Transaction Hierarchy (Polymorphism)}
The core of the system is the \texttt{Transaction} family, designed to treat Incomes and Expenses uniformly while allowing for specific behaviors.

\begin{itemize}
    \item \textbf{Base Class (\texttt{Transaction}):} An abstract class that encapsulates shared attributes:
    \begin{itemize}
        \item \texttt{id} (String): Unique UUID for the record.
        \item \texttt{amount} (Double): The monetary value.
        \item \texttt{date} (\texttt{Date}): Custom date object for chronological sorting.
        \item \texttt{walletId} (String): Foreign key linking to a specific Wallet.
    \end{itemize}
    \item \textbf{Derived Class (\texttt{Income}):} Inherits from \texttt{Transaction}.
    \item \textbf{Derived Class (\texttt{Expense}):} Inherits from \texttt{Transaction}.
    \item \textbf{Design Rationale:} By using inheritance, we can store all records in a single container (\texttt{ArrayList<Transaction*>}). This simplifies global operations like "Calculate Total Balance" or "Sort by Date," as the system iterates through one list rather than two separate ones.
\end{itemize}

\subsubsection{Automation Model (\texttt{RecurringTransaction})}
This class operates independently from the main transaction list. It acts as a "Factory" or "Template."
\begin{itemize}
    \item \textbf{Attributes:} Stores scheduling logic (\texttt{Frequency}, \texttt{StartDate}, \texttt{EndDate}) and a snapshot of the transaction data to be created.
    \item \textbf{Behavior:} It contains a \texttt{GenerateTransaction()} method. When the \texttt{AppController} detects a due date, this method instantiates a new concrete \texttt{Income} or \texttt{Expense} object, effectively cloning the template into a real record.
\end{itemize}

\subsubsection{Master Data Entities}
These distinct classes serve as reference data for validation and categorization.
\begin{itemize}
    \item \textbf{\texttt{Wallet}:} Represents a storage location. It maintains a mutable \texttt{balance} attribute that is updated whenever a transaction is added or removed.
    \item \textbf{\texttt{Category}:} Represents expense classifications (e.g., "Food", "Rent").
    \item \texttt{\textbf{IncomeSource}:} Represents income origins (e.g., "Salary", "Bonus").
\end{itemize}

\subsection{Binary Persistence Engine}
To meet the requirement for binary storage[cite: 70], we developed the \texttt{BinaryFileHelper} utility.
\begin{itemize}
    \item \textbf{Serialization:} Data is written directly as bytes using \texttt{ofstream::write}. Variable-length strings are prefixed with a size header to ensure correct reading.
    \item \textbf{The Factory Pattern:} A significant challenge was deserializing polymorphic objects. We solved this by writing a "Type Identifier" (Integer) before each object in the file. During reading, the \texttt{Transaction::FromBinary} factory method reads this ID first and dynamically instantiates the correct subclass (\texttt{Income} or \texttt{Expense}).
\end{itemize}

\subsection{Cross-Platform Compatibility}
As a console application, ensuring consistent behavior across Windows and macOS was a priority.
\begin{itemize}
    \item \textbf{Build System:} We utilized \textbf{CMake} to abstract compiler differences. We provided a \texttt{.bat} script for Windows (auto-detecting MinGW or Visual Studio) and a \texttt{.command} script for macOS (using Clang/Make).
    \item \textbf{Terminal Abstraction:} We implemented a \texttt{PlatformUtils} module. It uses preprocessor directives (\texttt{\#ifdef \_WIN32}) to switch between Windows API commands (e.g., \texttt{cls}) and POSIX commands (e.g., ANSI escape codes) for clearing the screen and handling unbuffered input.
\end{itemize}

\subsection{UI Techniques}
    We used several techniques to make the console UI usable and easy to test:
    \begin{itemize}
    \item \textbf{Layered rendering API} — `ConsoleView` provides primitives (headers, boxed panels, tables, colored lines) so high-level screens can be composed consistently across features.
    \item \textbf{Consistent menus and shortcuts} — `Menus` centralizes text and shortcuts so each flow uses the same input conventions (number keys to select, ESC to cancel/back).
    \item \textbf{Explicit input validation} — `InputValidator` checks money, dates, indexes and strings before handing control to the controller; this prevents invalid state and simplifies error handling.
    \item \textbf{Small, single-responsibility flows} — each `Nav*` method implements a single flow (e.g., add expense, edit income) and is kept short so unit testing and review are straightforward.
    \item \textbf{Clear user feedback} — success/error/warning/info helpers are used consistently so test scripts and manual testers can assert expected outcomes easily.
    \item \textbf{Terminal-aware formatting} — `PlatformUtils` normalizes terminal specifics so colors and simple formatting work on Windows and POSIX terminals.
    \end{itemize}

\subsection{Short walkthrough — each feature}
    The walkthrough below is split into small parts; each describes how the UI supports a feature, the user steps, and the relevant code points. This list covers all main menu features.

    \subsubsection{Dashboard}
    \begin{itemize}
    \item Goal: show quick status (date, total balance, list of wallets and counts of transactions).
    \item UI: `Dashboard::Display` prints the header, total balance (green/red), and a table of wallets (`src/Views/DashBoard.cpp`).
    \end{itemize}

    \begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{img/DashBoard.png}
    \caption{Main dashboard (date, total balance, wallets)}
    \label{fig:dashboard}
    \end{figure} 

    \subsubsection{Main Menu}
    \begin{itemize}
    \item Goal: provide entry points to all app features via numbered options.
    \item UI: `Menus::DisplayMainMenu` shows options and prints a shortcut footer. Navigation is handled by `NavigationController::Run`.
    \end{itemize}

    \begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{img/MainMenu.png}
    \caption{Main menu with shortcuts}
    \label{fig:main_menu}
    \end{figure}

    \subsubsection{Income (Add / View / Edit / Delete + Manage Sources)}
    \begin{itemize}
    \item Add: select wallet, amount (validated), date, description, source; `NavigationController::HandleAddIncome` then `AppController::AddTransaction`.
    \item View/Edit/Delete: listing and index-based selection flows are implemented in `HandleViewIncome`, `HandleEditIncome` and `HandleDeleteIncome`.
    \item Sources management: CRUD flows for income sources live in `NavIncome` methods.
    \end{itemize}

    \subsubsection{Expense (Add / View / Edit / Delete + Manage Categories)}
    \begin{itemize}
    \item Add: wallet, amount, date, description, category; `NavigationController::HandleAddExpense` calls `AppController::AddTransaction`.
    \item View/Edit/Delete and Category management: handled via `NavExpense` and category flows.
    \end{itemize}

    \subsubsection{Wallets (Create / View / Delete)}
    \begin{itemize}
    \item Create: `HandleCreateWallet` prompts for name and initial balance and calls `AppController::AddWallet`.
    \item View/Delete: lists and index-selection flows in `NavWallet`.
    \end{itemize}

    \subsubsection{Reports and Analytics}
    \begin{itemize}
    \item Monthly summary, spending by category, income-vs-expense and wallet balance overview are implemented in `NavReport` and use `AppController` aggregation helpers.
    \end{itemize}

    \subsubsection{Recurring Transactions}
    \begin{itemize}
    \item Create/View/Edit/Delete: full CRUD is implemented in `NavRecurring` and `AppController` provides scheduling logic.
    \end{itemize}

    \subsubsection{Search / Clear / Save Data}
    \begin{itemize}
    \item Search: provides indexed search over transactions and wallets, callable from many menus; implemented in `NavSearch` and helpers in `AppController`.
    \item Clear / Save Data: data-management actions (export, save, clear sample data) are implemented in the data-flow controllers and `BinaryFileHelper`.
    \end{itemize}

\subsection{Files evidence}
    \begin{itemize}
    \item Views: `include/Views/ConsoleView.h`, `src/Views/ConsoleView.cpp`, `include/Views/Menus.h`, `src/Views/Menus.cpp`, `include/Views/DashBoard.h`, `src/Views/DashBoard.cpp`.
    \item Input helpers: `include/Views/InputValidator.h`, `src/Views/InputValidator.cpp`.
    \item Controllers: `include/Controllers/NavigationController.h`, `src/Controllers/Nav*.cpp`, `src/Controllers/AppController.cpp`.
    \item Models and utils: `src/Models/*`, `src/Utils/BinaryFileHelper.cpp`, `src/Utils/IdGenerator.cpp`, `src/Utils/Date.cpp`.
    \item Entry: `src/main.cpp` wires the controllers and UI.
    \end{itemize}

