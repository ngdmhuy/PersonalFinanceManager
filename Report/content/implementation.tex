\section{System Implementation Details}

This section details the implementation of the core application logic, focusing on data modeling, utilities, and the AI handling.

\subsection{Utilities: ID Generation}
To ensure referential integrity across the system without relying on fragile memory pointers, every entity (Transaction, Wallet, Category, etc) is assigned a unique string identifier.

\subsubsection{Implementation Strategy}
We implemented a custom \texttt{IdGenerator} class to handle unique key creation.

\begin{itemize}
    \item \textbf{Algorithm:} The generator utilizes the \textbf{Mersenne Twister 19937} engine (\texttt{std::mt19937}), seeded by a non-deterministic random device (\texttt{std::random\_device}). This ensures a uniform distribution and minimizes the risk of ID collisions.
    \item \textbf{Format:} IDs are generated in a human-readable format: \texttt{PREFIX-XXXX-XXXX-XXXX}. 
    \item \textbf{Composition:} The random blocks consist of alphanumeric characters (A-Z, a-z, 0-9), selected from a charset of size 62.
\end{itemize}

\subsubsection{Role in Data Modeling}
As illustrated in Figure \ref{fig:schema}, these IDs serve as the backbone of our relational model.
\begin{itemize}
    \item \textbf{Primary Keys:} Every \texttt{transactions} and \texttt{wallets} record holds a unique \texttt{id} field.
    \item \textbf{Foreign Keys:} Relationships are maintained by storing string references (e.g., \texttt{walletId}) rather than memory pointers. This allows the system to serialize data to binary files safely without complex pointer swizzling.
\end{itemize}

\subsection{Data Modeling \& Entity Relationships}
The system utilizes a relational design pattern adapted for object-oriented programming. As shown in Figure \ref{fig:schema}, the data model relies on unique string identifiers (UUIDs) to maintain relationships between entities, avoiding the complexity and risks of raw memory pointers.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{Report/img/UMLdiagram.png}
    \caption{Entity Relationship Diagram}
    \label{fig:schema}
\end{figure}

\subsubsection{Core Transactions}
The \texttt{transactions} entity represents the central ledger of the application. It utilizes a polymorphic design to handle both inflows and outflows.
\begin{itemize}
    \item \textbf{Common Attributes:} All records share standard financial data:
    \begin{itemize}
        \item \texttt{id}: The unique primary key.
        \item \texttt{walletId}: A foreign key linking the transaction to a specific \texttt{Wallet}.
        \item \texttt{amount}: The monetary value.
        \item \texttt{date}: The timestamp of the transaction.
        \item \texttt{type}: A discriminator string ("Income" or "Expense").
    \end{itemize}
    \item \textbf{Classification References:} Depending on the transaction type, the record links to a specific classification entity:
    \begin{itemize}
        \item \textbf{Expenses:} Utilize the \texttt{categoryId} foreign key to link to the \texttt{categories} table.
        \item \textbf{Incomes:} Utilize the \texttt{incomeSourceId} foreign key to link to the \texttt{income\_sources} table.
    \end{itemize}
\end{itemize}

\subsubsection{Automation Model (Recurring Transactions)}
The \texttt{recurring\_transactions} entity serves as a "Blueprint" for future data generation.
\begin{itemize}
    \item \textbf{Scheduling Logic:} Unlike standard transactions, this entity includes frequency data (\texttt{frequency}, \texttt{startDate}, \texttt{endDate}) and tracking state (\texttt{lastGeneratedDate}).
    \item \textbf{Independence:} These records do not affect wallet balances directly. Instead, the system polls these blueprints upon startup to generate concrete \texttt{transactions} when due dates are reached.
\end{itemize}

\subsubsection{Master Data Entities}
The system maintains three lightweight reference entities to enforce data validation.
\begin{itemize}
    \item \textbf{Wallets:} Stores the current \texttt{balance} and account \texttt{name}.
    \item \textbf{Categories:} Defines expense classifications (e.g., "Food", "Rent").
    \item \textbf{Income Sources:} Defines income origins (e.g., "Salary", "Dividends").
\end{itemize}

\subsection{Binary Persistence Engine}
To meet the requirement of preserving data across sessions, we implemented a custom serialization engine (\texttt{BinaryFileHelper}). This module handles the low-level translation of C++ objects into a binary stream.

\subsubsection{Generic Serialization Templates}
To avoid repetitive code, we implemented generic wrapper functions for reading and writing primitive types.

\begin{itemize}
    \item \textbf{Template Approach:} We utilized \texttt{template<typename T>} functions to handle standard data types (\texttt{int}, \texttt{double}, \texttt{bool}). These functions cast the memory address of variables to \texttt{char*} and write them directly to the \texttt{std::ofstream} buffer.
    \item \textbf{String Handling:} Variable-length strings (such as descriptions) pose a challenge in binary files. We solved this by first writing the length of the string (\texttt{size\_t}) as a header, followed immediately by the character data. This allows the reader to know exactly how many bytes to extract during deserialization.
\end{itemize}

\subsubsection{Persistence Strategy: Snapshots vs. In-Place Editing}
A significant engineering decision involved how to handle updates (e.g., editing a transaction).
\begin{itemize}
    \item \textbf{The Problem:} Implementing "In-Place" editing in a binary file is highly complex. Changing a description from "Food" (4 bytes) to "Groceries" (9 bytes) would require shifting all subsequent bytes in the file, which is error-prone and slow.
    \item \textbf{The Solution (Snapshotting):} Instead of modifying specific bytes, we adopted a \textbf{"Full Rewrite" strategy}. Whenever data is saved, the system rewrites the entire \texttt{transactions.bin} file from scratch using the current memory state.
\end{itemize}

\subsubsection{Integration with Auto-Save}
Because rewriting the entire file can be computationally expensive (relative to a single byte update), we offloaded this task to the background thread mentioned in the \textbf{Technical Core} section.
\begin{itemize}
    \item \textbf{Frequency:} The \texttt{AutoSaveWorker} triggers this "Snapshot" process every 60 seconds.
    \item \textbf{Benefit:} This ensures that the expensive I/O operation never blocks the user interface (Main Thread), while still guaranteeing that the disk storage is never more than one minute behind the live data.
\end{itemize}

\subsection{Cross-Platform Infrastructure}
Making a console application run smoothly on both Windows and macOS is surprisingly difficult. While the logical C++ code is the same, the "Terminal" itself behaves very differently on each operating system. We built a translation layer to bridge this gap.

\subsubsection{The Problem: "Speaking Different Languages"}
Simple commands like "Clear Screen" or "Wait for Key Press" are not standard in C++.
\begin{itemize}
    \item \textbf{Windows} uses specific system commands (like \texttt{cls}).
    \item \textbf{macOS/Linux} relies on special text codes (ANSI escape sequences).
\end{itemize}

\textbf{Our Solution:} We created a \texttt{PlatformUtils} file that acts as a translator. It checks which OS is running and automatically chooses the correct command, so the rest of our app doesn't have to worry about it.

\subsubsection{One-Click Build Scripts}
We didn't want users to memorize complex compilation commands. We wrote simple scripts for each OS:
\begin{itemize}
    \item \textbf{Windows:} \texttt{run\_windows.bat} (Detects compiler and builds).
    \item \textbf{macOS:} \texttt{run\_mac.command} (Sets permissions and runs).
\end{itemize}

\subsection{UI Techniques}
    We used several techniques to make the console UI usable and easy to test:
    \begin{itemize}
    \item \textbf{Layered rendering API} — `ConsoleView` provides primitives (headers, boxed panels, tables, colored lines) so high-level screens can be composed consistently across features.
    \item \textbf{Consistent menus and shortcuts} — `Menus` centralizes text and shortcuts so each flow uses the same input conventions (number keys to select, ESC to cancel/back).
    \item \textbf{Explicit input validation} — `InputValidator` checks money, dates, indexes and strings before handing control to the controller; this prevents invalid state and simplifies error handling.
    \item \textbf{Small, single-responsibility flows} — each `Nav*` method implements a single flow (e.g., add expense, edit income) and is kept short so unit testing and review are straightforward.
    \item \textbf{Clear user feedback} — success/error/warning/info helpers are used consistently so test scripts and manual testers can assert expected outcomes easily.
    \item \textbf{Terminal-aware formatting} — `PlatformUtils` normalizes terminal specifics so colors and simple formatting work on Windows and POSIX terminals.
    \end{itemize}

\subsection{Short walkthrough — each feature}
    The walkthrough below is split into small parts; each describes how the UI supports a feature, the user steps, and the relevant code points. This list covers all main menu features.

    \subsubsection{Dashboard}
    \begin{itemize}
    \item Goal: show quick status (date, total balance, list of wallets and counts of transactions).
    \item UI: `Dashboard::Display` prints the header, total balance (green/red), and a table of wallets (`src/Views/DashBoard.cpp`).
    \end{itemize}

    \begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{img/DashBoard.png}
    \caption{Main dashboard (date, total balance, wallets)}
    \label{fig:dashboard}
    \end{figure} 

    \subsubsection{Main Menu}
    \begin{itemize}
    \item Goal: provide entry points to all app features via numbered options.
    \item UI: `Menus::DisplayMainMenu` shows options and prints a shortcut footer. Navigation is handled by `NavigationController::Run`.
    \end{itemize}

    \begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{img/MainMenu.png}
    \caption{Main menu with shortcuts}
    \label{fig:main_menu}
    \end{figure}

    \subsubsection{Income (Add / View / Edit / Delete + Manage Sources)}
    \begin{itemize}
    \item Add: select wallet, amount (validated), date, description, source; `NavigationController::HandleAddIncome` then `AppController::AddTransaction`.
    \item View/Edit/Delete: listing and index-based selection flows are implemented in `HandleViewIncome`, `HandleEditIncome` and `HandleDeleteIncome`.
    \item Sources management: CRUD flows for income sources live in `NavIncome` methods.
    \end{itemize}

    \subsubsection{Expense (Add / View / Edit / Delete + Manage Categories)}
    \begin{itemize}
    \item Add: wallet, amount, date, description, category; `NavigationController::HandleAddExpense` calls `AppController::AddTransaction`.
    \item View/Edit/Delete and Category management: handled via `NavExpense` and category flows.
    \end{itemize}

    \subsubsection{Wallets (Create / View / Delete)}
    \begin{itemize}
    \item Create: `HandleCreateWallet` prompts for name and initial balance and calls `AppController::AddWallet`.
    \item View/Delete: lists and index-selection flows in `NavWallet`.
    \end{itemize}

    \subsubsection{Reports and Analytics}
    \begin{itemize}
    \item Monthly summary, spending by category, income-vs-expense and wallet balance overview are implemented in `NavReport` and use `AppController` aggregation helpers.
    \end{itemize}

    \subsubsection{Recurring Transactions}
    \begin{itemize}
    \item Create/View/Edit/Delete: full CRUD is implemented in `NavRecurring` and `AppController` provides scheduling logic.
    \end{itemize}

    \subsubsection{Search / Clear / Save Data}
    \begin{itemize}
    \item Search: provides indexed search over transactions and wallets, callable from many menus; implemented in `NavSearch` and helpers in `AppController`.
    \item Clear / Save Data: data-management actions (export, save, clear sample data) are implemented in the data-flow controllers and `BinaryFileHelper`.
    \end{itemize}

\subsection{Files evidence}
    \begin{itemize}
    \item Views: `include/Views/ConsoleView.h`, `src/Views/ConsoleView.cpp`, `include/Views/Menus.h`, `src/Views/Menus.cpp`, `include/Views/DashBoard.h`, `src/Views/DashBoard.cpp`.
    \item Input helpers: `include/Views/InputValidator.h`, `src/Views/InputValidator.cpp`.
    \item Controllers: `include/Controllers/NavigationController.h`, `src/Controllers/Nav*.cpp`, `src/Controllers/AppController.cpp`.
    \item Models and utils: `src/Models/*`, `src/Utils/BinaryFileHelper.cpp`, `src/Utils/IdGenerator.cpp`, `src/Utils/Date.cpp`.
    \item Entry: `src/main.cpp` wires the controllers and UI.
    \end{itemize}

