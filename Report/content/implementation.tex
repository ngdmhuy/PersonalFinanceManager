\section{Technical Core}

This section describes the core technical mechanisms and algorithms that form the foundation of the system.
These components are independent from user interface or controller logic and focus purely on data integrity,
performance, and correctness.

\subsection{Core Data Structures}

The system is built upon custom generic data structures to maintain full control over memory usage and behavior.

\begin{itemize}
    \item \textbf{ArrayList<T>} — dynamic array used for ordered collections.
    \item \textbf{HashMap<K, V>} — hash-based associative container for fast key-based access.
\end{itemize}

Each structure is designed to be deterministic, serializable, and independent of STL containers to simplify debugging
and binary persistence.

\subsection{Algorithmic Components}

\subsubsection{Sorted Insertion by Date}

All transactions are maintained in chronological order based on their date.

\begin{itemize}
    \item \textbf{Algorithm:} Binary search to determine insertion position, followed by indexed insertion.
    \item \textbf{Purpose:} Preserves global ordering without requiring full re-sorting after each insertion.
\end{itemize}

\textbf{Procedure:}
\begin{enumerate}
    \item Perform binary search on the sorted list to find the first position where
    \texttt{existingDate $\ge$ newDate}.
    \item Insert the new element at the computed index.
\end{enumerate}

\textbf{Time Complexity:}
\begin{itemize}
    \item Binary search: $O(\log n)$
    \item Array insertion shift: $O(n)$
    \item Overall: $O(n)$
\end{itemize}

\textbf{Invariant:}  
The transaction list is always sorted in non-decreasing order of date.

\subsubsection{Indexed Lookup (Secondary Indices)}

To support fast filtering without repeated full scans, secondary index maps are maintained.

\begin{itemize}
    \item Wallet-based index
    \item Category-based index
    \item Income-source-based index
\end{itemize}

Each index maps an entity ID to a list of related transactions.

\textbf{Algorithm:} Hash-based indexing with append-only updates.

\textbf{Operations:}
\begin{itemize}
    \item Insert transaction reference into one or more index lists.
    \item Remove reference upon deletion or modification.
\end{itemize}

\textbf{Time Complexity:}
\begin{itemize}
    \item Insert / Remove: $O(1)$ average
    \item Query by indexed key: $O(k)$ where $k$ is number of related transactions
\end{itemize}

\textbf{Design Rationale:}  
This approach trades small memory overhead for significant query performance gains compared to repeated linear scans.

\subsubsection{Range Query on Sorted Data}

Date-range queries leverage the sorted nature of the transaction list.

\textbf{Algorithm:} Binary search followed by linear scan.

\begin{enumerate}
    \item Binary search to locate the first transaction with date $\ge$ start date.
    \item Sequentially iterate until date $>$ end date.
\end{enumerate}

\textbf{Time Complexity:}
\begin{itemize}
    \item Binary search: $O(\log n)$
    \item Range scan: $O(m)$ where $m$ is number of results
\end{itemize}

\textbf{Invariant:}  
Transactions are strictly ordered by date, enabling early termination.

\subsubsection{Recurring Transaction Scheduling}

Recurring entries act as templates for generating future transactions.

\textbf{Algorithm:} Incremental date progression.

\begin{itemize}
    \item Each recurring record stores its last generated date.
    \item The next due date is computed deterministically from frequency rules.
\end{itemize}

\textbf{Procedure:}
\begin{enumerate}
    \item Compare next due date with current date.
    \item If due, generate a concrete transaction and advance the schedule.
    \item Repeat until the template is no longer due.
\end{enumerate}

\textbf{Time Complexity:}
\begin{itemize}
    \item Per recurring record: $O(g)$ where $g$ is number of generated instances
\end{itemize}

\textbf{Invariant:}  
Each recurring transaction is generated exactly once per valid period.

\subsubsection{Search and Filtering Engine}

Search and filter operations are implemented using predicate-based linear scans.

\textbf{Algorithm:} Linear filtering with lambda predicates.

\textbf{Use Cases:}
\begin{itemize}
    \item Search by keyword
    \item Filter by type
    \item Filter by amount range
\end{itemize}

\textbf{Time Complexity:} $O(n)$

\textbf{Rationale:}  
These operations are user-driven and operate on manageable data sizes, making linear scans acceptable while keeping the
core logic simple and predictable.

\subsection{Concurrency and Data Safety}

The technical core enforces thread safety through mutual exclusion.

\begin{itemize}
    \item \textbf{Mechanism:} Recursive mutex locking
    \item \textbf{Scope:} All read/write operations on shared data structures
\end{itemize}

\textbf{Invariant:}  
At most one thread may mutate core data structures at any given time.

\textbf{Benefit:}  
Prevents race conditions while allowing re-entrant calls within the same execution flow.
